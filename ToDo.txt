ORGANIZAR CLASES

Clase Solver
	
	METODO SOLVE{
		- Crear rede do problema
		- Crear modelo inicial
		- Crear subproblem solvers
		- Crear parametros globales:
			- ZInc = infinity
			- processedNodes = 0
			- vector<Node*> solutions;
			- routeNumber;
		- Crear rootNode
			- pasar el modelo inicial
			- vHash e cHash
		status = BAP(rootNode);
		return status;
	}END SOLVE
	
	METODO SolveByCG(*node){
		end = false;
		node->resetVarRank();
		
		ENQUANTO QUE(!end)
			cgStatus = node->solve();
			SE(cgStatus != OPTIMAL)
				RETURN INFEASIBLE.
			FIM SE
						
			sw = 0
			PARA CADA TIPO DE EQUIPAMENTO
				newRoutes = sp->generateColumns(node->getModel(), eqType)
				SE sp.infeasible 
					RETURN INFEASIBLE
				FIM SE
			FIM PARA
			PARA CADA ROTA
				//Adicionar variavel dual faltante custo da rota
				SE rota.custo >= 0 CONTINUE
				rota->setRouteNumber(routeNumber++);
				bools sucess = node->addColumn(rota);
				SE success
					sw = 1;
				ELSE
					print("Error: column " << rota.routeNumber << "," << rota.eqType << " already existed in node " << node.id);
				FIM SE
			FIM PARA
			
			SE sw == 0
				end = true
			FIM SE
		FIM ENQUANTO QUE
		
		RETURN OTIMO
	}FIM SolveByCG
	
	METODO BAP(*rootNode){
		pilha.push(rootNode);
		EM QUANTO QUE  pilha.size() > 0
			node = pilha.top;
			pilha.pop
			node->id = processedNodes++;
			
			status = solveByCG(node)	
			
			sw = 0
			SE status != Optimal 
				delete(node)
				sw = 1
			ELSE
				Zlp = node->model->getObjVal
				SE SOLUÇÃO X INTEIRA
					SE ZInc > Zlp
						solutions.push_back(node);
						Zinc = Zlp
					FIM SE
					sw = 1
				ELSE IF (Ceil(Zlp) >= Zinc)
					delete(node)
					sw = 1;
				FIM SE
			FIM SE
			
			IF sw == 1 CONTINUE
			
			maxRotas = 200;
			node->clean(maxRotas)
				
			maxRC = ZInc - Zlp
			node->fixByReducedCosts(maxRC)					
				
			nodeIzq = new Node(node); //copia
			nodeDer = new Node(node); //copia
			
			//BRANCHING SIMPLES
			Variable branchV = node->getMostFractional();				
			
			//STRONG BRANCHING
			NOT YET
			
			nodeIzq->addBranchRestriction(branchV, 0);
			nodeIzq->addBranchRestriction(branchV, 1);
			
			pilha.push(nodeIzq);
			pilha.push(nodeDer);	
			delete(node);
		FIM ENQUANTO QUE
	}FIM METODO BAP
				
Class Variavel
	- Adicionar campo rank. //OK
	- Adicionar campo fractionality. //OK
	- Adicionar campo score //OK
	- Modificar Hash <Variable, bool> //OK
	- Comparator de variaveis por fractionality //OK
	- Comparator de variaveis por Rank //OK
	- Comparator de variaveis por score. //OK

Class Constraint
	- Crear tipo BRANCH //OK
	- Adicionar campo rank //OK
	- Modificar Hash <Constraint, bool> //OK
	- Comparator de variaveis por Rank //OK
	
Class NODE
	- Construtor Padrão
	- Construtor (Node) //clona um node, FAZER COPIA
	- Destrutor
		- Apagar vHash, cHash, model e rotas.
	
	- int Id
	- *model
	- Var hash	(não tem referencia à variavel do modelo, so nome)
		- Necessaria para percorrer variaveis para fazer node cleaning.
	- Constr hash (não tem referencia a variavel do model, so nome)
		- Guardar inteiro (Rank) (possivel uso futuro, adicionar e tirar cortes).
	- Routes.
	- Zlp
	
	METODO SOLVE(){ //OK
		int status = model->solve();
		if(status != OPTIMAL)
			return status
			
		updateVariables();		
		return status;
	}
	
	METODO UPDATE VARIABLES(){ //OK
		PARA CADA Var no vHash
			SE NÃO Variavel na base
				Variavel.rank ++;
			FIM SE
			Variavel.value = model->getVarByName....
			Variable.fractionality = abs(value - 0.5);
		FIM PARA
	}
	
	METODO GETMOSTFRACTIONAL(){ //OK
		mostFractional = (*vHash.begin())->first;
		PARA CADA Var do vHash
			if var.fractionality < mostFracional.fractionality
				mostFractional = var
			end if
		FIM PARA
		return mostFracional;		
	}
	
	METODO ADDBRANCHCONSTRAINT(Variable v, double rhs){ //OK
		GRBVar var = ....
		GRBLinExpr expre += var;
		model->addConstr...
	}
	
	METODO ADDCOLUMN(rota){ //OK
		Criar Variable lambda
		SE lambda não existe no vHash
			criar variavel lambda no modelo
			adicionar variavel lambda ao vHash
			inserir coluna (coeficientes)
			node.Routes += route
			sw = 1
		FIM SE
	}
	
	METODO FIX BY REDUCED COSTS(max){ //OK
		PARA CADA Variavel Y e X no vHAsh
			myVar = model->getVar()
			rc = myVar->getReducedCost();
			SE rc >= max ENTÃO
				apagar variavel do modelo
				apagar variavel do vHash
			FIM SE
		FIM PARA					
	}END FIX BY RC
	
	METODO CLEAN(max){
		cont = 0
		PARA CADA LAMBDA
			SE lambda esta na base ENTÃO
				cont++
			FIM SE
		FIM PARA
		
		PARA CADA LAMBDA EM VARS (ORDENADAS POR RANK)
			SE cont < max 
				cont ++ 
			ELSE
				apagar lambda do node-model;
				apagar lambda do node->vHash
			FIM SE
		FIM PARA
	}FIM CLEAN
	
- Subproblem Solver
	- Recibir modelo master e tipo de equipamento em metodo solve.
	- Retornar rota(s) sem importar custo reduzido.
				
		
DUDAS
1) restrição de branching como corte ou lb/ub???
	- Revição de fixação em subproblema.
4) Quais estatisticas guardar?